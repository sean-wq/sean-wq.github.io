[{"title":"力扣-替换所有问号","url":"/2022/04/30/力扣—替换所有的问号（1576）/","content":"\n\n\n### 替换所有的问号（1576）\n\n##### 一、问题\n\n给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。\n\n注意：你 不能 修改非 '?' 字符。\n\n题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。\n\n在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。\n\n##### 二、例子\n\n```\n输入：s = \"??yw?ipkj?\"\n输出：\"acywaipkja\"\n```\n\n```\n输入：s = \"ubv?w\"\n输出：\"ubvaw\"\n解释：该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n```\n\n##### 三、思考\n\n​\t重点是在于将？替换成其他字符，并且字符不可以连续重复，也就是说可以多种答案出现，难度比较简单。\n\n​\t解决方法很简单，就是比较当前字符，如果是？则将用StringBuilder对象存入24个字母中的一个，只要它对比前后两个字符**不要连续重复**即可。那么我们设置前字符的下标变量为pre，而后字符的下标变量next。\n\n​\t因为前字符都来自StringBuilder对象（已过滤？的字符），所以无需有判断是否是？的步骤。如果后字符是？的情况，那只需要对比前字符即可，因为当前下标是会循环完所有的字符，这样做也就等于同时对比了前后这两个字符的情况。如果后字符不是？的情况，只需对比前后两个字符是否相同，并且代替的字符不跟这两个字符的相等即可。\n\n​\t最后再加上一些，例外情况，如？是在开头或者结尾等，基本实现代码如下。\n\n##### 四、代码实现\n\n```java\nclass Solution {\n    public String modifyString(String s) {\n        char[] words = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\n        StringBuilder sb = new StringBuilder();\n    \n        for(int i=0;i < s.length();i++){\n            char c = s.charAt(i);\n            //判断是否进行替换操作\n            if(c == '?'){\n                //判断？的位置是否为头部\n                if(sb.length() != 0){\n                    char pre = sb.charAt(sb.length()-1);\n                    char next =  i+1 != s.length() ? s.charAt(i+1)  : ' ';\n                    //如果next不是？的情况\n                    if(next != '?' && next != ' '){\n                        char t = ' ';\n                        for(int j =0;j < words.length;j++){\n                            //判断替换的字符与next和pre不一样\n                            if(pre != words[j]){\n                                if(next != words[j]){\n                                    t = words[j];\n                                    break;\n                                }\n                            }\n                        }\n                        if(t != ' '){\n                            sb.append(t);\n                        }\n                     //如果next是？或者是空的情况\n                    }else{\n                        for(int j =0;j < words.length;j++){\n                            if(pre != words[j]){\n                                sb.append(words[j]);\n                                break;\n                            }\n                        }\n                    }\n                 //如果？位置在头部\n                }else{\n                    if(i+1 != s.length()){\n                        char next = s.charAt(i+1);\n                         for(int j =0;j < words.length;j++){\n                            if(next != words[j]){\n                                sb.append(words[j]);\n                                break;\n                            }\n                        }\n                    }else{\n                        sb.append(words[0]);\n                    }\n                }\n                //如果不进行替换操作，不改变当前字符，加入到StringBuilder对象中\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n\n    }\n}\n```\n\n","tags":["力扣","连续不重复字符","算法"],"categories":["笔记"]},{"title":"经典排序算法总结","url":"/2021/12/22/经典排序算法总结/","content":"\n### 经典排序算法总结\n\n*最近在复习一下leetcode的算法题，发现自己对排序算法相关的知识记忆不深刻，数据结构里学的相关算法都忘得差不多了，并且自己之前做的笔记也找不到了，面对排序相关问题都没有思路下手。所以我打算借这次刷算法的题的机会，把之前所学习的内容复习一遍，并且做好电子版的笔记，将其记录下来，以后也可以比较轻松的复习相关知识！*\n\n##### 1、关于冒泡排序\n\n冒泡排序算是比较简单的排序算法了吧，它的原理非常简单，就是通过对比相邻的两个元素，逐渐的把这次比较结果里最大的数放到最后一位，在完成这次排序操作后，数组下标将重新返回数组的第一项元素并且重复以上操作一直到排序完成。\n\n###### （1）代码实现\n\n```java\npublic static int[] bubbleSort(int[] array){\n  if(array.length == 0)return array;\n  for(int i = 0;i<array.length;i++){\n    //一步步减少j循环的界限，因为冒泡排序的右边是已经完成排序的排列\n    for(int j=0;j<array.length-i-1;j++){\n      //两个元素之间交换位置\n      if(array[j]>array[j+1]){\n        int temp = array[j+1];\n        array[j+1] = array[j];\n        array[j] = temp;\n        \n      }\n    }\n  }\n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)  \n\n##### 2、关于选择排序\n\n选择排序是最稳定的排序算法之一，工作原理就是：在未排序的区域找到最小（或最大值）的元素，并将其交换放在第一位，接下来就分已排序区域和未排序区域，每次找到未排序区域的最小值（或最大值）将其加入到已排序区域的最后一位，多次重复操作直到数值有序化。\n\n###### （1）代码实现\n\n```java\npublic static int[] selectSort(int[] array){\n  \tif(array.length==0)return array;\n  \tfor(int i=0;i<array.length;i++){\n      int minIndex = i;\n      for(int j = i;j<array.length;j++){\n        if(array[j]<array[minIndex]){\n          minIndex = j;\n        }\n      }\n      int temp = array[minIndex];\n      array[minIndex] = array[i];\n      array[i] = temp;\n    }\n  \n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n2)   最差情况：T(n) = O(n2)  \n\n##### 3、关于插入排序\n\n###### （1）代码实现\n\n插入排序是默认从第二个数据开始比较，如果第二个数据比第一个数据小，则交换。然后在用第三个数据比较，如果比前面小则插入，否则退出循环。\n\n```java\npublic static int[] insertSort(int[] array){\n  \tif(array.length==0)return array;\n  \tfor(int i=1;i<array.length;i++){\n      for(int j = i;j > 0 ;j--){\n        if(array[j] < array[j-1]){\n          int temp = array[j-1];\n          array[j-1] = array[j];\n          array[j] = temp;\n        }else{\n          break;\n        }\n      }\n      \n    }\n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)  \n\n##### 4、关于快速排序\n\n快速排序是对冒泡排序的一种改进，它的基本思想就是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快排，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n###### （1）代码实现\n\n首先设定一个分界值，通过该分界值分成左右两个部分，将大于或等于分界值得数据集中到数组的右边，小于分界值得数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或分界值。然后就是在左右两边分别在取分界值，重复以上的步骤，最后得到的就是已经排序好的数组。\n\n```java\npublic static int[] quickSort(int[] array,int left,int right){\n\n        if(left < right){\n            int partitionIndex = partition(array,left,right);\n            quickSort(array,left,partitionIndex-1);\n            quickSort(array,partitionIndex + 1,right);\n        }\n        return array;\n    }\n    private static int partition(int[] array,int left,int right){\n        int pivot = left;\n        int index = pivot + 1;\n        for(int i = index; i <= right; i++){\n            if(array[i] < array[pivot]){\n                swap(array,i,index);\n                index++;\n            }\n        }\n        swap(array,pivot,index -1);\n        return index - 1;\n    }\n    private static void swap(int[] array,int i,int j){\n        int temp  = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n\n    }\n```\n\n\n\n###### （2）算法分析\n\n快速排序的性能在理想的情况下时间复杂度为：O(nlog2n)，最坏的情况下时间复杂度为：O(n2)","tags":["算法","排序"],"categories":["笔记"]},{"title":"记录M1芯片安装MySQL的步骤","url":"/2021/10/16/记录M1芯片安装MySQL的步骤/","content":"\n\n\n## MacOS M1芯片安装MySQL的步骤\n\n最近因为换了M1芯片的电脑，一些生产环境都要重新配置一下，毕竟CPU的架构换了，开发工具也需要更换成相对应的版本，MySQL就是其中的一个。因为在MySQL在docker下都是x64架构的，直接运行\n\n`docker pull mysql1`\n\n会报错“no matching manifest for linux/arm64/v8 in the manifest list entries”\n\n#### 1、下载镜像\n\n我们需要运行\n\n`docker pull mysql/mysql-server`\n\n在等待下载完成\n\n#### 2、启动容器\n\n启动docker容器，做好3306端口映射，设置密码为123456\n\n`docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql/mysql-server`\n\n#### 3、进入容器\n\n`docker exec -it mysql /bin/bash`\n\n正常情况输入mysql -uroot -p后登陆\n\n#### 4、修改可远程登陆设置\n\n`update user set host='%' where user='root';`\n\n最后flush privileges即可","tags":["M1","MySQL","docker"],"categories":["笔记"]},{"title":"记录n1盒子刷openwrt系统的步骤还有遇到的坑","url":"/2021/07/19/n1盒子刷openwrt系统的步骤还有遇到的坑/","content":"\n\n\n##                      n1盒子刷openwrt系统的步骤还有遇到的坑\n\n#### 1.斐讯n1的优点\n\n最近发现了openwrt系统的可玩性很高，除了有基本的WiFi无线功能外，系统还可以提供非常丰富的服务功能（很多都是我想要的）。通过精挑细选，我最终决定最高性价比的斐讯n1盒子。\n\n斐讯n1接口丰富：电源接口、千兆网口、HDMI、两个USB接口\n\n硬件配置：\n\n​\tCPU: S905D\n\n​\t内存：2G\n\n​    闪存：8G\n\n​\tWiFi：5G\n\n看到这样的配置才一百来块，心动不如行动，赶紧下单入坑。 \n\n#### 2.系统设置所踩到的坑\n\n本着省事的原则，在购买的时候就提前让卖家刷好openwrt系统，我拿到手后就可以直接使用了，结果事与愿违，在我进入页面的设置步骤的时候，嫌等待时间过长就把盒子的电源线拔了重插，结果后台管理页面就无法进入了。 \n\n进入电脑的网络设置观察，路由器的IP地址未知，但我通过显示器连接n1盒子看到系统是正常启动的，也就是很有可能是无线方面功能出了问题。没办法，只能自己重刷一次系统了。自己找了刷机教程慢慢探索\n\n#### 3.重新刷机步骤\n\n（1）准备一个U盘，下载diskgenius删除隐藏分区还有格式化U盘。\n\n（2）然后再下载balenaEtcher将op系统的img文件写入U盘。\n\n（3）等待写入完成后，就重启盒子（重启之前要插入U盘）。\n\n（4）现在盒子就会自动启动U盘里面的op系统，接下来就是输入一下两条命令\n\n`cd /root`\n\n`./install-to-emmc.sh`\n\n（5）后面就是按照脚本自动写入emmc，等待脚本写入完毕后就可以拔掉U盘，重新启动n1盒子了。\n\n#### 4.无线设置\n\n在浏览器中输入192.168.1.1，输入密码password进入管理后台。点击网络-接口-lan口-物理设置，把eth0选项去掉。新建一个接口，物理设置选择刚刚的eth0以太网适配器，然后在基本设置里选择PPPoE拨号，输入账号和密码后点击保存应用。现在就可以正常的上网了。\n\n","tags":["openwrt","n1盒子","linux","emmc"],"categories":["笔记"]},{"title":"使用注解@RequiresAuthentication出现的问题","url":"/2021/03/05/使用@RequiresAuthentication注解的时候，访问控制器报404/","content":"\n\n\n使用@RequiresAuthentication注解的时候，访问控制器报404\n\n这时候需要在shiro配置类加上\n\n```\n//Shiro注解支持\n@Bean\npublic AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\n    AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\n    authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\n    return authorizationAttributeSourceAdvisor;\n}\n\n@Bean\npublic static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n\n    DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n    defaultAdvisorAutoProxyCreator.setUsePrefix(true);\n\n    return defaultAdvisorAutoProxyCreator;\n}\n```","tags":["注解","404错误"],"categories":["笔记"]},{"title":"shiro+jwt登录认证anon配置无效","url":"/2021/02/24/shiro+jwt登录认证anon配置无效/","content":"\n\n\n\n\n# shiro+jwt登录认证anon配置无效\n\n> \n\nshiroConfig的配置\n\n```java\n @Bean\n    public ShiroFilterFactoryBean factory(DefaultWebSecurityManager securityManager) {\n\n        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();\n\n        Map<String, Filter> filters = new HashMap<>();\n        filters.put(\"jwt\",new JwtFilter());\n        factoryBean.setFilters(filters);\n        factoryBean.setSecurityManager(securityManager);\n\n        Map<String, String> filterMap = new LinkedHashMap<>();\n\n        filterMap.put(\"/user/login\",\"anon\");\n        filterMap.put(\"/index/test\",\"anon\");\n        filterMap.put(\"/**\",\"jwt\");\n\n        factoryBean.setFilterChainDefinitionMap(filterMap);\n\n        return factoryBean;\n    }\n```\n\n\n\n结果发现\n\n` filters.put(\"jwt\", jwtFilter);`\n\n如果把jwtFilter注册里面的ioc容器bean的话\n\n访问所有的链接都会被拦截\n\n\n\n把jwtFilter的注入方式，改成new的话就anon配置就可以生效\n\n```\nfilters.put(\"jwt\", new JwtFilter()); \n1\n```\n\n但这样做的话，就无法使用自动注入的jwtUtil对象了\n\n这时候可以使用自己封装的spring上下文来获得bean\n\n```java\n if (jwtUtils == null) {\n        jwtUtils = ApplicationContextUtils.getBean(\"jwtUtils\");\n    }\n123\n```\n\n这样就可以成功注入了","tags":["shiro","jwt"],"categories":["笔记"]},{"title":"git工具的用法","url":"/2021/02/18/git用法/","content":"\n\n\n\n\n# git用法\n\n\n\n\n\ngit add 添加文件到缓存区\n\ngit commit -m \"描述\"从缓存区添加到版本库\n\ngit status 查看状态\n\n\n\ngit remote add orgin [url]  添加远程仓库\n\ngit  push origin master 添加版本库里面的内容到远程仓库\n\n\n\n\n\n#### 版本退回(返回上个commit版本)\n\ngit reset --hard head^\n\n^代表上个版本\n\n也可以head~100\n\n\n\ngit log 查找每次更新的版本号\n\ngit reset --hard [版本号]\n\n\n\n#### 撤销操作使用条件\n\ngit checkout -- file \n\n1.原本文件需要修改的文件没有添加到缓存区，现在撤销修改就回到版本库里面一样的\n\n2.原本的文件已经添加到缓存区里面，现在工作区修改错误，撤销修改就回到缓存区里面一样的\n\n\n\ngit reset HEAD file\n\n1.修改错误的文件已经添加到缓存区里面，就可以把暂存区的修改退回到工作区\n\n\n\n\n\n#### 分支\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`或者`git switch <name>`\n\n创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n\n\n#### bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n\n\n#### 多人协作\n\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n","tags":["git"],"categories":["学习"]},{"title":"正则表达式的规则","url":"/2021/01/02/首先是以下正则表达式的规则/","content":"\n\n\n\n\n\n\n今天要用到Java正则表达式来处理判断Ip地址是否正确的问题，所以复习一下正则表达式的相关知识\n\n# 首先是以下正则表达式的规则\n\n\\1. 任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。\n\n\\2. []代表匹配中括号中其中任一个字符，如[abc]匹配a或b或c。\n\n\\3. -在中括号里面和外面代表含义不同，如在外时，就匹配-，如果在中括号内[a-b]表示匹配26个小写字母中的任一个；[a-zA-Z]匹配大小写共52个字母中任一个；[0-9]匹配十个数字中任一个。\n\n\\4. ^在中括号里面和外面含义不同，如在外时，就表示开头，如^7[0-9]表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如[^abc]表示匹配出去abc之外的其他任一字符。\n\n\\5. .表示匹配任意的字符。\n\n\\6. \\d表示数字。\n\n\\7. \\D表示非数字。\n\n\\8. \\s表示由空字符组成，[ \\t\\n\\r\\x\\f]。\n\n\\9. \\S表示由非空字符组成，[^ \\ s 。\n\n\\10. \\w表示字母、数字、下划线，[a-zA-Z0-9_]。\n\n\\11. \\W表示不是由字母、数字、下划线组成。\n\n\\12. ?: 表示出现0次或1次。\n\n\\13. +表示出现1次或多次。\n\n\\14. *表示出现0次、1次或多次。\n\n\\15. {n}表示出现n次。\n\n\\16. {n,m}表示出现n~m次。\n\n\\17. {n,}表示出现n次或n次以上。\n\n\\18. XY表示X后面跟着Y，这里X和Y分别是正则表达式的一部分。\n\n\\19. X|Y表示X或Y\n\n\\20. (X)子表达式，将X看做是一个整体。\n\n上面的正则表达式的规则是非常简单明了的\n\nip地址的匹配的正则表达式是\n\n```java\n\"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\"\n```\n\n","tags":["正则表达式"],"categories":["学习"]},{"title":"Mac下安装Homebrew的步骤","url":"/2020/12/28/Macos系统安装Homebrew的步骤/","content":"\n\n\n\n\n### Mac下安装Homebrew的步骤\n\n##### 今天发现原来macos里面也有类似的linux系统里面的yum包管理系统--Homebrew，拥有它就可以轻松方便地为电脑安装安装你想要的软件或者命令，例如wget，只要输入brew install wget就可以一键完成下载操作了。但因为在国内访问国外源的速度很慢，还是换国内源比较好，现在记录一下安装Homebrew的安装和换源步骤\n\n### Hombrew安装的方法：\n\n官方给出的安装方法\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n但这个脚本一般在我们国内用不了，非常慢，所以我们需要换成以下的命令\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\"\n```\n\n如果卡在以下的信息：\n\n```shell\n==> Tapping homebrew/core\nCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...\n```\n\n请`ctrl+c断脚本执行如下命令：\n\n```shell\ncd \"$(brew --repo)/Library/Taps/\"\nmkdir homebrew && cd homebrew\ngit clone git://mirrors.ustc.edu.cn/homebrew-core.git\n```\n\n成功执行之后继续执行前文的安装命令。\n\n最后看到`==> Installation successful!`就说明安装成功了。\n\n`cask`同样也有首次下载缓慢的问题，解决方法大致同上：\n\n```shell\ncd \"$(brew --repo)/Library/Taps/\"\ncd homebrew\ngit clone https://mirrors.ustc.edu.cn/homebrew-cask.git\n```\n\n最后执行：\n\n```shell\nbrew update\n```\n\n### 换镜像：中科大源\n\n```shell\ngit -C \"$(brew --repo)\" remote set-url origin https://mirrors.ustc.edu.cn/brew.git\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git\n\nbrew update\n\n# 长期替换homebrew-bottles\necho 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' >> ~/.bash_profile\nsource ~/.bash_profile\n```\n\n注意`bottles`可以临时设置，在终端执行下面命令：\n\n```shell\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\n```\n\n### 卸载Homebrew\n\n一样使用以下的脚本就可以卸载：\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall)\"\n```\n\n### 恢复\n\n```shell\ngit -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git\n\nbrew update\n```\n\n`homebrew-bottles`配置只能手动删除，将 `~/.bash_profile`文件中的 `HOMEBREW_BOTTLE_DOMAIN=https://mirrors.xxx.com`内容删除，并执行 `source ~/.bash_profile`。\n\n### Homebrew基本用法\n\nbrew list  —列出已安装的软件\n\nbrew update  —更新Homebrew\n\nbrew home *—用浏览器打开\n\nbrew info  *—显示软件内容信息\n\nbrew deps * — 显示包依赖\n\nbrew server * —启动web服务器，可以通过浏览器访问http://localhost:4567/ 来同网页来管理包\n\nbrew –help —查看brew的帮助\n\nbrew install git —安装软件\n\nbrew uninstall  —卸载软件\n\nbrew search   —搜索软件\n\nbrew upgrade  —更新某具体软件\n\nbrew cleanup —删除程序，和upgrade一样，单个软件删除和所有程序老版删除。\n\nbrew outdated —查看那些已安装的程序需要更新","tags":["MacOS","Homebrew"],"categories":["笔记"]},{"title":"学习@Autowired和@Resource注解区别","url":"/2020/12/27/@Autowired和@Resource注解区别/","content":"\n\n\n\n\n\n\n### @Autowired和@Resource注解区别\n\n#### 当我们遇到以下情况的时候，@AutowireJ注解注入就会抛出异常\n\n```\npublic Interface UserService(){\n\tUser selectById(Integer id);\n}\n```\n\n```\n@service(\"userservice1\")\npublic class UserServiceImp1() implements UserService{\n\t@Override\n\tpublic User selectById(Integer id){}\n}\n```\n\n```\n@service(\"userservice2\")\npublic class UserServiceImp2() implements UserService{\n\t@Override\n\tpublic User selectById(Integer id){}\n}\n```\n\n####  这时候就需要运用到@Qualifier注解就可以解决这个问题\n\n```@\n@Autowired\n@Qualifier(name=\"userservice1\")\nprivate UserService userSerivce;\n```\n\n#### 或者使用@Resource\n\n```\n@Resource(name=\"userserivce1\")\nprivate UserService userSerivce;\n```\n\n#### 总结\n\n##### 1.@Autowired和@Resource都可以用来配装bean\n\n##### 2.@Autowired是根据类型进行自动配装，如果有多个类型一样的Bean的候选者的时候，就需要限定其中一个候选者，否者会抛出异常。但可以配合@Qualifier注解使用，例如：\n\n```\n@Autowired\n@Qualifier(\"baseDao\")\nprivate BaseDao basDao;\n```\n\n##### 3.@AUtowired如果想要允许Null,可以设置它的required属性为false\n\n##### 4.@Resource默认按name注入，可以通过name和type属性进行选择性注入","tags":["spring"],"categories":["笔记"]},{"title":"mybatis-plus时出现错误的解决的方法","url":"/2020/12/26/记录使用mybatis-plus时出现错误的解决办法/","content":"\n\n\n\n\n### 记录使用mybatis-plus时出现错误的解决办法\n\n今天想测试一下mybatis-plus框架的实用性，结果遇到了报错问题一直解决不了，现在先把如何解决的方法记录一下\n\n#### 1.引用mybatis-plus框架\n\n#### 2.创建实体类User\n\n#### 3.创建一个UserMapper\n\n```\n@Mapper\npublic interface UserMapper extends BaseMapper<User> {\n}\n```\n\n#### 4.application.yml内容\n\n```\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true\n    username: root\n    password: 12345678\n\nmybatis-plus:\n  configuration:\n    map-underscore-to-camel-case: true\n    auto-mapping-behavior: full\n  mapper-locations: classpath*:mapperxml/*Mapper.xml\n  global-config:\n    # 逻辑删除配置\n    db-config:\n      # 删除前\n      logic-not-delete-value: 1\n      # 删除后\n      logic-delete-value: 0\n```\n\n#### 5.在测试类直接测试\n\n```\n@Autowire\nprivate UserMapper userMapper\n\n@Test\n    void contextLoads() {\n        User user = new User();\n        user.setUid(1);\n        user.setBalance(150);\n        user.setPassword(\"123456\");\n        user.setUname(\"xiao\");\n        System.out.println(userMapper.insert(user));\n    }\n```\n\n#### 6.结果报错Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required\n\n查找到以下的解决方法：\n\n##### （1）springboot启动类的@SpringBootApplication注解去掉exclude= {DataSourceAutoConfiguration.class}\n\n###### 没办法解决，因为并没有使用到exclude= {DataSourceAutoConfiguration.class}这个选项\n\n##### （2）dao层是继承于一个dao基类，所以只要在这个基类中注入任意一个属性\n\n```\n public class CommonDao extends SqlSessionDaoSupport {\n    @Resource\n     public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory){\n         super.setSqlSessionFactory(sqlSessionFactory);\n     }\n```\n\n无法解决，因为dao层mapper使用的都是接口，并且都是继承BaseMapper\n\n##### （3）加入以下依赖\n\n```\n<dependency>\n\t\t\t<groupId>com.alibaba</groupId>\n\t\t\t<artifactId>druid-spring-boot-starter</artifactId>\n\t\t\t<version>1.1.9</version>\n</dependency>\n```\n\n加入了也没有起作用\n\n最后在别人的mybatis-plus项目找到了相符合的版本，修改成以下的依赖才解决此问题\n\n```\n<dependency>\n<groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus</artifactId>\n    <version>2.1.8</version>\n</dependency>\n        <dependency>\n         <groupId>com.baomidou</groupId>\n         <artifactId>mybatisplus-spring-boot-starter</artifactId>\n          <version>1.0.5</version>\n</dependency>\n```\n\n最后想要说明的是，使用mybatis-plus时，要注意把mybatis,mybatis-spring的依赖删掉，以免造成不必要的冲突\n\n","tags":["mybatis-plus"],"categories":["笔记"]},{"title":"学习@Bean和@Commponent的区别","url":"/2020/12/26/@Bean 和 @Component的区别/","content":"\n\n\n# @Bean 和 @Component的区别\n\n## 前言　　\n\n最近研究Springboot 源码的时候发现这两个注解比较常出现，但是放眼看去这两个注解好像功能都差不多，所以专门研究了一下：\n\n------\n\n \n\n## 注解作用\n\n- @Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。\n- @Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。\n\n \n\n------\n\n \n\n## 两者对比\n\n相同点：两者的结果都是为spring容器注册Bean.\n\n不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。\n\n　　　　@Bean 注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。\n\n------\n\n## 理解\n\n@Component （@Controller @Service @Respository）作用于类上，只有在我们的SpringBoot应用程序启用了组件扫描并且包含了被注解的类时才有效。通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context，这里有的不足就是会把整个类当成bean注册到spring 容器上，如果这个类中并不是所有方法都需要注册为bean的话，会出现不需要的方法都注册成为bean，这时候必须确保这些不需要的方法也能注册为bean或者在扫描中加filter 过滤这些不需要的bean,否者spring将无法成功启动。\n\n@Bean相对来说就更加灵活了，它可以独立加在方法上，按需注册到spring容器，而且如果你要用到第三方类库里面某个方法的时候，你就只能用@Bean把这个方法注册到spring容器，因为用@Component你需要配置组件扫描到这个第三方类路径而且还要在别人源代码加上这个注解，很明显是不现实的。","tags":["spring","注解"],"categories":["笔记"]},{"title":"mysql定时自动备份","url":"/2020/12/23/记录自己今天实现两台服务器中的docker环境下mysql自动备份/","content":"\n\n\n\n\n### 记录自己今天实现两台服务器中的docker环境下mysql自动备份\n\n我这台谷歌云服务器相对于国内几家云服务器来讲不稳定，不知道会因为什么原因突然连不上，那服务器里面的mysql数据库没了就真的没了。加上国内屏蔽了谷歌的服务，如果以后想进入谷歌云控制台对服务器进行操作的话还需要翻墙，整体来讲太麻烦了，所以我计划把这台服务器的在docker容器里面的Mysql进行备份，然后根据脚本定时向我另外一台阿里云服务器进行传输备份文件，保证数据不丢失。今天查了一下，发现实现还是挺简单的，所以记录一下。\n\n### 1.配置两服务器的免密码sshd登录\n\n为实现阿里云免登录到谷歌云的服务器上\n\n首先在阿里云服务器上输入\n\n```linux\n#查看是否生成公钥和秘钥文件 \nls ~/.ssh\n\n#如果没有生成id_rsa 和id_rsa.pub文件就执行以下代码\nssh-keygen -t rsa\n\n#查看id_rsa.pub里面的内容,并复制\ncat id_rsa.pub\n```\n\n接下来在谷歌云服务器上输入\n\n```\nvi ~/.ssh/authorized_keys\n把上面复制内容粘贴在这文件上，输入wq保存\n```\n\n最后成功实现阿里云ssh免密码连接到谷歌云服务器\n\n\n\n### 2.在谷歌云服务器设置定时任务，每天备份mysql里面的数据\n\n编写备份的脚本 backupdb.sh\n\n```shell\n#!/bin/sh\ndb_user=\"数据库用户名\"\ndb_passwd=\"数据库密码\"\ndb_name=\"需要备份的数据库名\"\nCONTAINERNAME=\"docker容器的名\"\nname=\"$(date +\"%Y%m%d%H%M%S\")\"\ndocker exec -i $CONTAINERNAME /usr/bin/mysqldump -u$db_user -p$db_passwd $db_name >>/var/lib/docker/volumes/_data/backup/$name.sql\n# 保留最近一个月的数据\nfind /var/lib/docker/volumes/_data/backup -type f -mtime +20 -name \"*.sql\" -exec rm -rf {} \\;\n```\n\n启动定时任务\n\n```\n# 启动定时任务\ncrontab -e\n# 每天的3点30分执行脚本\n30 3 * * * /bin/bash /usr/data/backup/backupdb.sh\n\n# 查看定时任务列表\ncrontab -l\n```\n\n\n\n可以看到到计划时间后，已经成功保存备份文件\n\n![截屏2020-12-23 下午12.21.38](/Users/mac/Library/Application Support/typora-user-images/截屏2020-12-23 下午12.21.38.png)\n\n\n\n\n\n### 3.阿里云设置定时脚本，通过scp命令，每天定时的传备份文件过来\n\n编写\n\n定时任务脚本back.sh\n\n```shell\n#!/bin/sh\nname=\"$(date +\"%Y%m\")\"\nServerIp=\"你的服务器ip地址\"\nscp root@$ServerIp:/var/lib/docker/volumes/_data/backup/$name*.sql /usr/data/backupdb/ \n```\n\n启动定时任务\n\n```\n# 启动定时任务\ncrontab -e\n# 每天的12点01分执行脚本\n01 12 * * * /bin/bash /usr/data/backup/back.sh\n\n# 查看定时任务列表\ncrontab -l\n```\n\n阿里云可以看到成功显示备份文件\n\n![截屏2020-12-23 下午12.33.09](/Users/mac/Library/Application Support/typora-user-images/截屏2020-12-23 下午12.33.09.png)\n\n\n\n\n\n### 4.总结一下遇到的小问题\n\nscp传输的时候总要明确文件名，总不能每次传输把以前的备份文件都传一遍吧，但两台服务器的时间不一样，文件又想以时间命名方便一点管理，又不想改变两台服务器的时间。这时候就需要想个解决这个困难的方法，对比两台服务器的时间，我们就以当前时间为标准，因为此时是同日期但不同小时分钟的，而且我们设定的备份的频率是每天一次，所以备份文件的前面的年月是不同的，那我们以匹配相同时间前缀，这样就可以阿里云服务器就可以确保备份到最新的sql文件\n\n","tags":["linux","docker","mysql"],"categories":["笔记"]}]