[{"title":"AI工具分析","url":"/2026/02/02/AI工具分析/","content":"\n#### 1.负责搜索链接，总结分析产品卖点，生产文案\n\n##### **免费：** ChatGPT/Gemini/Grok（国内DeepSeek，千问Qwen也可以）\n\n复制以下prompt模板，替换店铺链接给AI，让AI分析\n\n```\n请分析以下产品链接内容，输出结构化结果：\n\n【产品链接】\n{{product_url}}\n\n【任务要求】\n1. 分析产品的核心卖点（至少 5 点），要求：\n   - 每个卖点 1 句话总结 + 简要说明理由\n   - 卖点必须基于链接页面内容，而不是凭空编写\n\n2. 生成可直接用于电商运营的产品文案，包括：\n   - 30 字以内短标题（适合主图文字）\n   - 80～120 字产品简介（适合详情页开头）\n   - 5 条高转化要点文案（bullet points）\n\n3. 输出适合生成 AI 主图/详情图的「图片要点」：\n   - 主图应该展示哪些元素？\n   - 场景图布局建议？\n   - 卖点展示图需要哪些画面？\n   - 适合加入哪些文字（例如：耐用 / 三层加强 / 轻便等）\n\n【输出格式】\n请严格按以下结构输出：\n\n### 一、产品卖点分析\n1.\n2.\n3.\n4.\n5.\n\n### 二、产品文案\n- 标题：\n- 产品简介：\n- 卖点文案：\n\n### 三、图片要点建议\n（主图建议、场景图建议、卖点图建议等）\n\n如果链接无法正常打开，请提示我。\n```\n\n##### **收费版：**writesonic（https://writesonic.com/）\n\n参考学习教程：https://www.toolify.ai/zh/ai-news-cn/ai%E9%AB%98%E6%95%88%E7%94%9F%E6%88%90%E7%94%B5%E5%95%86%E4%BA%A7%E5%93%81%E6%8F%8F%E8%BF%B0writesonic%E5%AE%9E%E6%93%8D%E6%95%99%E7%A8%8B-3526900\n\n#### 2.图片分析，以图生图\n\n普通版：AI模型都可以给提示词生成\n\n```\n请分析我提供的产品图片，识别产品类型、材质、颜色和使用方式。\n基于原图产品生成新的电商图片，要求：\n\n【产品保持一致】\n- 保持产品主体结构不变\n- 保留关键颜色与外形特征\n- 不出现品牌、不出现logo\n\n【图片风格】\n- XXX风格（如：极简风 / 高级质感 / 生活场景 / 小清新）\n- 背景：XXX（如：白底、厨房场景、户外、桌面摆拍）\n\n【构图要求】\n- 产品居中/靠左/靠右\n- 留白空间，用于文案排版\n- 光线柔和、高亮度、商业摄影质感\n\n【电商平台规则】\n- 不违规，不夸张，不使用敏感关键词\n- 图片不出现人体敏感部位\n- 适配（亚马逊/速卖通）主图规范\n\n【清晰度】\n- 高分辨率、4K细节、锐利边缘、无噪点\n```\n\n##### 专业版：Midjourney（https://www.midjourney.com/）\n\n参考Midjourney学习教程：\n\nhttps://blog.csdn.net/2401_84830464/article/details/138845721\n\nhttps://blog.csdn.net/Eqiqi/article/details/147983480\n\nhttps://ai.feishu.cn/wiki/QZl4wqipXi3PF6k1JzIcQ4JYnwh\n\n#### 3.提供产品白底图，AI数字人，生成产品视频\n\n##### -PiPit AI（https://www.pippit.ai/zh-cn）\n\n字节系，集成电商平台，门槛低\n\n##### -HeyGen （https://www.heygen.com/zh-cn/video/app-tutorial-generator）\n\n质量比较高\n\n教程：https://zhuanlan.zhihu.com/p/682336572\n","tags":["AI","ChatGPT","Midjourney","HeyGen"],"categories":["笔记"]},{"title":"Excel表处理新行插入通用的方法","url":"/2026/02/02/Excel表处理新行插入通用的方法/","content":"\nExcel表处理新行插入，并且底部有数据的时候，适用的方法\n\nopenpyxl库中可以使用的一些方法\n\n```\ndef copy_row_with_style_formula_merge_cells(ws, src_row, target_row):\n    max_col = ws.max_column\n    # print(f\"目前插入的行有：{target_row}\")\n    # if merge_sheet_name == '申报要素':\n    #     ws.insert_rows(src_row)\n    # else:\n    ws.insert_rows(target_row)\n    #行高一致\n    if ws.row_dimensions[src_row].height:\n        ws.row_dimensions[target_row].height = ws.row_dimensions[src_row].height\n\n    for col in range(1, max_col + 1):\n        src_cell = ws.cell(row=src_row, column=col)\n        dst_cell = ws.cell(row=target_row, column=col)\n\n        # 跳过 MergedCell 类型的单元格，因为它们的 value 属性是只读的\n        if not isinstance(dst_cell, MergedCell):\n            # 检查是否为公式单元格\n            if src_cell.data_type == 'f' and src_cell.value:\n                # 计算行偏移量\n                offset = target_row - src_row\n                formula = src_cell.value\n\n                # 使用正则表达式查找并替换公式中的行引用\n                # 匹配单元格引用，如 A1, B23, $C$5, $D10, E$15 等\n                def adjust_cell_reference(match):\n                    col_ref = match.group(1)  # 列引用（可能包含$）\n                    row_ref = match.group(2)  # 行号\n\n                    # 如果行号前有$符号（绝对引用），则不调整\n                    if '$' in match.group(0) and match.group(0).index('$') < match.group(0).index(row_ref):\n                        return match.group(0)\n\n                    # 调整相对行引用\n                    new_row = int(row_ref) + offset\n                    return f\"{col_ref}{new_row}\"\n\n                # 匹配列引用和行号：$?[A-Z]+\\$?(\\d+)\n                # 分组1: $?[A-Z]+ (列引用，可能包含$)\n                # 分组2: \\d+ (行号)\n                adjusted_formula = re.sub(r'(\\$?[A-Z]+)\\$?(\\d+)', adjust_cell_reference, formula)\n                dst_cell.value = adjusted_formula\n            else:\n                # 非公式单元格，直接复制值\n                dst_cell.value = src_cell.value\n\n        if src_cell.has_style:\n            dst_cell._style = copy.copy(src_cell._style)\n\n        if src_cell.hyperlink:\n            dst_cell._hyperlink = copy.copy(src_cell.hyperlink)\n\n        if src_cell.comment:\n            dst_cell.comment = copy.copy(src_cell.comment)\n\n        for merged_range in list(ws.merged_cells.ranges):\n            # print(f\"merged_range: {merged_range}\")\n            min_row, min_col, max_row, max_col = merged_range.min_row, merged_range.min_col, merged_range.max_row, merged_range.max_col\n            # 判断该行是否在合并区域中\n            if min_row <= src_row <= max_row:\n                offset = target_row - src_row\n                new_range = (\n                    ws.cell(row=min_row + offset, column=min_col).coordinate\n                    + \":\" +\n                    ws.cell(row=max_row + offset, column=max_col).coordinate\n                )\n                ws.merge_cells(new_range)\n\n    # 复制行高\n    if ws.row_dimensions[src_row].height:\n        ws.row_dimensions[target_row].height = ws.row_dimensions[src_row].height)\n\n\n```\n\n此方法适合复制行的样式以及公式等，比较通用，直接复制即可用，现在记录下，后续可以直接使用\n","tags":["Python","Excel","openpyxl"],"categories":["笔记"]},{"title":"JS逆向-JS文件替换重写","url":"/2026/02/02/JS逆向-JS文件替换/","content":"\n#### JS逆向-JS文件替换重写\n\n为了方便调试查看某个变量变化情况，替换原来的代码，加上一些调试条件更容易找到，以下的步骤：\n\n**1.打开DevTools**\n\n**2.Sources-Overrides-新建一个文件夹**\n\n**3.Sources-Page-调试某个JS文件，右键Save AS到文件夹里面**\n\n**4.Enable Local Overrides启动**\n\n以下是部分替换逻辑\n\n```javascript\neu = (function() {\n    // 1. 保存原始的 set 函数\n    var _originalSet = er.setSessionList;\n\n    // 2. 返回一个新的函数作为替身\n    return function(newData) {\n        // 3. 只有当写入的数据不为空时，才断点（过滤掉初始化时的空数据）\n        if (newData && (Array.isArray(newData) ? newData.length > 0 : true)) {\n            console.log('%c[抓到了] 数据源头正在写入:', 'color:red; font-size:16px;', newData);\n\n            // ------------------------------------------------\n            debugger; // <--- 关键！看右侧 Call Stack (调用栈)\n            // ------------------------------------------------\n        }\n\n        // 4. 执行原始逻辑，保证页面不崩\n        return _originalSet.apply(this, arguments);\n    };\n})(),\n\nec = (function() {\n    // 1. 保存原始的 set 函数\n    var _originalSet = er.setSessionList;\n\n    // 2. 返回一个新的函数作为替身\n    return function(newData) {\n        // 3. 只有当写入的数据不为空时，才断点（过滤掉初始化时的空数据）\n        if (newData && (Array.isArray(newData) ? newData.length > 0 : true)) {\n            console.log('%c[抓到了] 数据源头正在写入:', 'color:red; font-size:16px;', newData);\n\n            // ------------------------------------------------\n           // debugger; // <--- 关键！看右侧 Call Stack (调用栈)\n            // ------------------------------------------------\n        }\n\n        // 4. 执行原始逻辑，保证页面不崩\n        return _originalSet.apply(this, arguments);\n    };\n})()\n```\n","tags":["JS","逆向","DevTools"],"categories":["笔记"]},{"title":"SQL遇到的多次计算结果","url":"/2026/02/02/SQL遇到的多次计算结果/","content":"\n### 2025-10-15笔记遇到的SQL问题\n\nMySQL中需要注意update时连续引用值赋值到别的字段，可能会造成重复计算的情况\n\n比如:\n\n```java\nString updateWeightedAmount = \"update amz_data_analysis_turnover_mskulist \" + \"set sales_amount = case \" +\n     \"WHEN sales_amount REGEXP '^\\\\\\\\(' THEN concat(REGEXP_SUBSTR(sales_amount,'[^0-9.-]'), -1 * CAST(REPLACE(REGEXP_REPLACE(sales_amount,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score ,2) \"\n    + \"ELSE concat(REGEXP_SUBSTR(sales_amount,'[^0-9.-]'), CAST(REPLACE(REGEXP_REPLACE(sales_amount,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score,2) \" + \"END,\"\n    + \"gross_profit = case \" + \"WHEN gross_profit REGEXP '^\\\\\\\\(' THEN concat(REGEXP_SUBSTR(gross_profit,'[^0-9.-]'), -1 * CAST(REPLACE(REGEXP_REPLACE(gross_profit,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score) \"\n    + \"ELSE concat(REGEXP_SUBSTR(gross_profit,'[^0-9.-]'), CAST(REPLACE(REGEXP_REPLACE(gross_profit,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score ) \" + \"END,\"\n    + \"sales_amount_format = case \"\n    + \"WHEN sales_amount REGEXP '^\\\\\\\\(' THEN -1 * CAST(REPLACE(REGEXP_REPLACE(sales_amount,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score \"\n    + \"ELSE CAST(REPLACE(REGEXP_REPLACE(sales_amount,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score \" +\"END,\"\n    + \"gross_profit_format = case \" + \"WHEN gross_profit REGEXP '^\\\\\\\\(' THEN -1 * CAST(REPLACE(REGEXP_REPLACE(gross_profit,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score \"\n    + \"ELSE CAST(REPLACE(REGEXP_REPLACE(gross_profit,'[^0-9.-]',''),' ','') AS DECIMAL(10,2)) * score \" + \"END \"\n    + \"where DATE(created_at) = CURDATE()\";\n```\n\ngross_profit_format字段就得到了gross_profit乘以两次score的值\n\n以下有两种办法，一种是update两次，一种是用子查询保存结果后再update\n\n```java\nString updateAllFields =\n    \"UPDATE amz_data_analysis_turnover_mskulist AS t \" +\n    \"JOIN ( \" +\n    \"  SELECT id, \" +\n    \"         CAST(REPLACE(REGEXP_REPLACE(sales_amount, '[^0-9.-]', ''), ' ', '') AS DECIMAL(10,2)) AS sa_value, \" +\n    \"         CAST(REPLACE(REGEXP_REPLACE(gross_profit, '[^0-9.-]', ''), ' ', '') AS DECIMAL(10,2)) AS gp_value, \" +\n    \"         sales_amount, gross_profit \" +\n    \"  FROM amz_data_analysis_turnover_mskulist \" +\n    \"  WHERE DATE(created_at) = CURDATE() \" +\n    \") AS orig ON t.id = orig.id \" +\n    \"SET \" +\n    \"t.sales_amount = CASE \" +\n    \"  WHEN orig.sales_amount REGEXP '^\\\\\\\\(' THEN CONCAT(REGEXP_SUBSTR(orig.sales_amount, '[^0-9.-]'), -1 * orig.sa_value * t.score) \" +\n    \"  ELSE CONCAT(REGEXP_SUBSTR(orig.sales_amount, '[^0-9.-]'), orig.sa_value * t.score) \" +\n    \"END, \" +\n    \"t.gross_profit = CASE \" +\n    \"  WHEN orig.gross_profit REGEXP '^\\\\\\\\(' THEN CONCAT(REGEXP_SUBSTR(orig.gross_profit, '[^0-9.-]'), -1 * orig.gp_value * t.score) \" +\n    \"  ELSE CONCAT(REGEXP_SUBSTR(orig.gross_profit, '[^0-9.-]'), orig.gp_value * t.score) \" +\n    \"END, \" +\n    \"t.sales_amount_format = CASE \" +\n    \"  WHEN orig.sales_amount REGEXP '^\\\\\\\\(' THEN -1 * orig.sa_value * t.score \" +\n    \"  ELSE orig.sa_value * t.score \" +\n    \"END, \" +\n    \"t.gross_profit_format = CASE \" +\n    \"  WHEN orig.gross_profit REGEXP '^\\\\\\\\(' THEN -1 * orig.gp_value * t.score \" +\n    \"  ELSE orig.gp_value * t.score \" +\n    \"END \" +\n    \"WHERE DATE(t.created_at) = CURDATE();\";\n```\n","tags":["SQL","MySQL","Java"],"categories":["笔记"]},{"title":"openpyxl库的一些问题","url":"/2026/02/02/openpyxl库的一些问题/","content":"\n#### Openpyxl库的一些问题\n\n在使用openpyxl插入表格的时候，如果插入的当前行下面有合并单元格的话，那插入的行数可能不生效或者融进合并单元格里面没有表现出来。这个这个时候尝试了几种方法解决\n\n##### 第一种方法：\n\n在模板文件中提前设置好足够多的待使用的行数，后面就不需要插入新的行，使用现成行即可，等完成插入动作后，再把多余的行数删去。\n\n##### 优点就是简单方便，缺点就是不够灵活,并且如果删除多余的行,那下面的行如果有合并单元格的话单元格也会失效.\n\n##### 第二种方法:\n\n先把整个sheet页的单元格都拆开,保存原来的合并区间参数,等插入动作完成后再按照原来的参数恢复\n\n##### 优点就是思路清晰,缺点就是实际恢复过程复杂,特别在插入行数后,原来保存的合并参数需要结合新的行数调整修改,整体实现起来比较复杂\n\n第三种方法:\n\n把下面合并单元格的内容复制到别的sheet页中,等插入行完毕后再把此sheet页的内容完整复制过去,这样需要处理的合并单元格将会大大减少,合并起来也比较快了\n\n```python\n    sheet_invoce = wb['发票']\n    start_row = 8\n    last = False\n    for fba_number,r_index in zip(new_fba_sku_packaging_info.keys(), range(len(new_fba_sku_packaging_info.keys()))):\n        if r_index == len(new_fba_sku_packaging_info.keys()) - 1:\n            last = True\n        new_type_info_list = copy_type_info_list(new_fba_sku_packaging_info[fba_number]['type_info_list'])\n        for type_info, l_index in zip(new_type_info_list, range(len(new_type_info_list))):\n            if l_index == len(new_type_info_list) - 1 and last:\n                pass\n            else:\n                copy_row_with_style_formula_merge_cells(sheet_invoce, start_row, start_row + 1)\n            # # 写入数据\n            sheet_invoce[f'A{start_row}'] = 'N/M'\n            sheet_invoce[f'C{start_row}'] = type_info['type_name']\n            sheet_invoce[f'D{start_row}'] = type_info['count']\n            sheet_invoce[f'F{start_row}'] = type_info['price_cost']\n            start_row += 1\n\n    start_row_new = start_row\n    #结尾处理\n    #复制sheet2内容到发票sheet的结尾\n    sheet2 = wb['Sheet2']\n\n    # 复制Sheet2的第1-4行到发票sheet的结尾\n    for source_row in range(1, 5):\n        # 插入新行\n        sheet_invoce.insert_rows(start_row)\n\n        # 复制行高\n        if sheet2.row_dimensions[source_row].height:\n            sheet_invoce.row_dimensions[start_row].height = sheet2.row_dimensions[source_row].height\n\n        # 遍历每一列，复制单元格内容和样式\n        max_col = sheet2.max_column\n        for col in range(1, max_col + 1):\n            src_cell = sheet2.cell(row=source_row, column=col)\n            dst_cell = sheet_invoce.cell(row=start_row, column=col)\n\n            # 跳过合并单元格（从单元格，后面统一处理合并区域）\n            if not isinstance(src_cell, MergedCell):\n                # 复制值\n                dst_cell.value = src_cell.value\n\n                # 复制样式\n                if src_cell.has_style:\n                    dst_cell.font = copy(src_cell.font)\n                    dst_cell.border = copy(src_cell.border)\n                    dst_cell.fill = copy(src_cell.fill)\n                    dst_cell.number_format = copy(src_cell.number_format)\n                    dst_cell.protection = copy(src_cell.protection)\n                    dst_cell.alignment = copy(src_cell.alignment)\n\n        start_row += 1\n\n    # 处理合并单元格\n    # 收集Sheet2中1-4行涉及的合并单元格区域\n    merged_ranges_to_copy = []\n    for merged_range in sheet2.merged_cells.ranges:\n        # 检查合并区域是否在1-4行范围内\n        if merged_range.min_row >= 1 and merged_range.max_row <= 4:\n            merged_ranges_to_copy.append(merged_range)\n\n    # 在发票sheet中创建对应的合并单元格\n    for merged_range in merged_ranges_to_copy:\n        # 计算新的行位置（从原来的start_row - 4开始）\n        row_offset = start_row - 4 - 1  # start_row已经+4了，所以需要-4，再-1因为从第1行开始\n        new_min_row = merged_range.min_row + row_offset\n        new_max_row = merged_range.max_row + row_offset\n\n        new_range = (\n            sheet_invoce.cell(row=new_min_row, column=merged_range.min_col).coordinate\n            + \":\" +\n            sheet_invoce.cell(row=new_max_row, column=merged_range.max_col).coordinate\n        )\n        sheet_invoce.merge_cells(new_range)\n\n    # # 设置公式\n    sheet_invoce[f'C{start_row_new}'] = f'=H{start_row_new}'\n    sheet_invoce[f'H{start_row_new}'] = f'=SUM(H8:H{start_row_new - 1})'\n\n```\n","tags":["Python","Excel","openpyxl"],"categories":["笔记"]},{"title":"二级路由设置过程","url":"/2026/02/02/二级路由设置过程/","content":"\n#### 二级路由预计设置过程：\n\n二级路由wan口连接主路由的lan口\n\n然后进入设置页面-外部网络-wan联机类型改成静态IP地址：192.168.101.21\n\n（方便访问）主路由设置界面-高级功能-静态路由-新增\n\n```\n规则名称：二级路由\n目的地址：192.168.2.0\n子网掩码：255.255.255.0\n下一跳：192.168.101.21\n```\n\n##### 主路由设置双wan口：\n\n将另一根光猫网线接入主路由\n\n基本设置-接口模式-双wan口-保存-重启路由\n\nwan设置-wan2设置：\n\n```\nPPPoE拨号\n用户名：075502129278@163.gd\n密码：TGMJENOP\n```\n","tags":["路由器","网络配置"],"categories":["笔记"]},{"title":"若依前端VUE框架出现的BUG问题","url":"/2026/02/02/若依前端VUE框架出现的BUG问题/","content":"\n#### 若依前端VUE框架出现的BUG问题\n\n在使用过程中有时候会出现切换菜单或者tab标签空白，点击无响应，需要重新刷新后又恢复正常的。这种情况比较偶发，也没有什么报错信息，网上搜下来看挺多人遇到这种问题的，下面分享我使用的解决办法：\n\n```vue\n<template>\n  <section class=\"app-main\">\n    <router-view v-slot=\"{ Component, route }\">\n      <transition name=\"fade-transform\" mode=\"out-in\">\n        <div :key=\"route.path\">\n        <keep-alive :include=\"tagsViewStore.cachedViews\">\n          <component v-if=\"!route.meta.link\" :is=\"Component\" :key=\"route.fullPath\"/>\n        </keep-alive>\n        </div>\n      </transition>\n    </router-view>\n    <iframe-toggle />\n  </section>\n</template>\n```\n\n主要还是出现在AppMain.vue上，需要在keep-alive上加一个div，这样子就能解决切换标签页面无响应的问题了，貌似还可以可以把transition去掉，需要的也可以尝试一下：\n\n```vue\n<template>\n  <section class=\"app-main\">\n    <router-view v-slot=\"{ Component, route }\">\n\n        <keep-alive :include=\"tagsViewStore.cachedViews\">\n          <component v-if=\"!route.meta.link\" :is=\"Component\" :key=\"route.fullPath\"/>\n        </keep-alive>\n\n    </router-view>\n    <iframe-toggle />\n  </section>\n</template>\n```\n","tags":["Vue","若依"],"categories":["笔记"]},{"title":"用selenium登录获取cookie后，需要留意跨域问题","url":"/2026/02/02/跨域问题/","content":"\n#### 用selenium登录获取cookie后，需要留意跨域问题\n\n在赋值cookie时需要把cookie的跨域修改，修改内容如下：\n\n```python\ncookies = driver.get_cookies()\n    session = requests.Session()\n    for cookie in cookies:\n        # 移除selenium特定的属性，保留requests需要的属性\n        for key in ['expiry', 'sameSite', 'httpOnly','PHPSESSID']:\n            cookie.pop(key, None)\n        # 强制覆盖 domain 和 path，确保支持跨子域访问\n        cookie['domain'] = '.mabangerp.com'\n        cookie['path'] = '/'\n        session.cookies.set(**cookie)\n        print(cookie)\n\n    response = session.get(\"https://aamz.mabangerp.com/index.php?mod=mainpage.index\")\n    print(response.headers.get('Set-Cookie'))\n```\n\n以上的cookie设置不止是跨域问题，还有后面想要达到导出文件的目的话，要先把PHPSESSID给删掉，后面再去访问aamz子域马帮接口才能够正确访问，而不会出现companyId未设置的错误\n","tags":["Python","Selenium","Cookie"],"categories":["笔记"]},{"title":"速卖通sign逆向","url":"/2026/02/02/速卖通sign逆向/","content":"\n### 速卖通sign逆向\n\n速卖通sign提取步骤：\n关键字：d.token\n关键片段： k = i(d.token + \"&\" + j + \"&\" + h + \"&\" + c.data)\n","tags":["逆向","速卖通"],"categories":["笔记"]},{"title":"速卖通爬虫登录弹窗解决办法","url":"/2026/02/02/速卖通爬虫登录弹窗解决办法/","content":"\n### 速卖通爬虫登录弹窗解决办法\n\n速卖通每天登录需要点击弹窗，并且弹窗内容样式不一样，虽然可以退出浏览器再重新登录后让此弹窗消失，但始终治标不治本。现在采取的方式就是爬虫启动时，也另起一个线程运行css样式注入+DOM删除双管齐下，让弹窗的样式消失，具体的代码如下：\n\n```python\ndef popup_cleaner(driver, interval=2):\n    \"\"\"守护线程，定时删除弹窗（CSS隐藏 + DOM删除）\"\"\"\n    js_code = \"\"\"\n    if (!document.getElementById('hide-ppp-style')) {\n        const style = document.createElement('style');\n        style.id = 'hide-ppp-style';\n        style.textContent = `\n        .next-overlay-wrapper.ppp-overlay-wrapper.opened {display:none !important;}\n        .box-guide-page-mask {display:none !important;}\n        .next-overlay-wrapper.opened {display:none !important;}\n        .next-overlay-inner.next-dialog-wrapper.next-dialog-centered {display:none !important;}\n        .next-overlay-backdrop {display:none !important;}\n        `;\n        document.head.appendChild(style);\n    }\n    \"\"\"\n\n    js_code_remove = \"\"\"\n    const selectors = [\n        '.next-overlay-wrapper.ppp-overlay-wrapper.opened',\n        '.box-guide-page-mask',\n        '.next-overlay-wrapper.opened',\n        '.next-overlay-inner.next-dialog-wrapper.next-dialog-centered',\n        '.next-overlay-backdrop'\n    ];\n\n    let removedCount = 0;\n    selectors.forEach(selector => {\n        const elements = document.querySelectorAll(selector);\n        elements.forEach(el => {\n            el.remove();\n            removedCount++;\n        });\n    });\n\n    return removedCount;\n    \"\"\"\n\n    while True:\n        try:\n            driver.execute_script(js_code)\n            print(\"注入CSS成功\")\n\n            removed_count = driver.execute_script(js_code_remove)\n            if removed_count > 0:\n                print(f\"删除弹窗元素成功，共删除 {removed_count} 个元素\")\n            else:\n                print(\"未发现需要删除的弹窗元素\")\n        except Exception:\n            print(\"执行弹窗清理失败，将退出守护线程\")\n            break  # driver 已关闭，退出守护线程\n        time.sleep(interval)\n\n```\n\n为了绕过网址的注入防御，需要用style.textContent。主要的原理就是循环注入CSS+DOM删除，防止速卖通随机出现弹窗，只要获得样式就能解决，不用每次都新增一条xpath代码了。\n","tags":["Selenium","速卖通","爬虫"],"categories":["笔记"]},{"title":"力扣-层数最深叶子节点的和（二叉树的层序遍历法）","url":"/2022/08/21/力扣-层数最深叶子节点的和（二叉树的层序遍历法）/","content":"\n\n\n#### 层数最深叶子节点的和（1302）\n\n##### 题目\n\n给你一棵二叉树的根节点 `root` ，请你返回 **层数最深的叶子节点的和** 。\n\n示例1:\n\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png)\n\n```\n输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n输出：15\n```\n\n示例2：\n\n```\n输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n输出：19\n```\n\n##### 分析\n\n这个求层数最深的叶子节点的和，事实上就是用二叉树层序遍历法来求的当前层数的叶子节点总和。用队列的先进先出的原理可实现层序遍历，具体原理可看到下图的遍历结果：\n\n![](https://img-blog.csdnimg.cn/img_convert/5800894497975eae47778a3dbe0a52a8.gif)\n\n根据这个思路，只要我们在每层遍历的途中，把每层的子节点的值相加记录下来。那么最后一层的遍历总和也肯定被记录下来，只要输出结果list的最后一个元素值，这个就是我们最深叶子节点的和了。\n\n##### 代码实现\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int deepestLeavesSum(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if(root == null){return 0;}\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\t\t//如果队列不为空则继续\n        while(!queue.isEmpty()){\n            //提前保存队列的长度，因为在调用poll方法后队列的长度会变化\n            int size = queue.size();\n            //初始化当前层数的和变量\n            int count = 0;\n            for(int i = 0; i < size;i++){\n                TreeNode node = queue.poll();\n                //计算总和\n                count += node.val;\n                //如果有左子节点则加入到队列中\n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                //如果有右子节点则加入到队列中\n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n            //加每层的节点值总和加入到list中\n            result.add(count);\n            count = 0;\n        }\n        //最后一层的总和就是list最后一个元素值\n        return result.get(result.size()-1);\n    }\n}\n```\n\n","tags":["力扣","二叉树","层序遍历"],"categories":["算法"]},{"title":"力扣-用户分组","url":"/2022/08/12/力扣-用户分组（1282）/","content":"\n### 用户分组（1282）\n\n##### **一、问题**\n\n有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。\n\n给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] = 3 ，则第 1 个人必须位于大小为 3 的组中。\n\n返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。\n\n每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。\n\n##### **二、例子**\n\n```\n输入：groupSizes = [3,3,3,3,3,1,3]\n输出：[[5],[0,1,2],[3,4,6]]\n解释：\n第一组是 [5]，大小为 1，groupSizes[5] = 1。\n第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。\n第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 \n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n\n```\n\n```\n输入：groupSizes = [2,1,3,3,3,2]\n输出：[[1],[0,5],[2,3,4]]\n```\n\n##### **三、思考**\n\n题目的要求仔细想象其实也非常的简单，重要的是在groupSize这个数组中，每个下标对应着一个值，这个值就是此下标所在List\\<Integer>的固定大小，如果所处的list的size的大小超过了groupSize[i]中的值，那么我们可以直接new一个新的list作为容器继续使用，而旧的list则可以作为一项结果。顺着这个思路，我们就能用map去实现控制固定值大小的list存储。\n\n##### **四、代码实现**\n\n```java\nclass Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n\n        //结果list\n        List<List<Integer>> result = new ArrayList<>();\n        //初始化一个list池子map，以list的固定大小作为key\n        Map<Integer,List<Integer>> listPoolMap = new HashMap<>();\n        //遍历group\n       for(int i = 0; i < groupSizes.length;i++){\n           //如果没有这个固定长度的list则新建一个，并加入到池子中去\n           if(listPoolMap.get(groupSizes[i]) == null){\n               List<Integer> list = new ArrayList<>();\n               list.add(i);\n               listPoolMap.put(groupSizes[i],list);\n           }else{\n               //如果已经有了这个固定长度的list\n               List<Integer> list = listPoolMap.get(groupSizes[i]);\n               //先判断这个list是否满了\n               if(list.size() == groupSizes[i]){\n                   //满了的话则加入到结果list中，并新建list,替换掉池子的旧list\n                   result.add(list);\n                   List<Integer> newList = new ArrayList<>();\n                   newList.add(i);\n                   listPoolMap.put(groupSizes[i],newList);\n               }else{\n                   //不满的话继续加入\n                   list.add(i);\n               }\n           }\n       }\n        //遍历完成后，把剩余的list全都加入进结果list中去\n        for (Map.Entry<Integer, List<Integer>> entry : listPoolMap.entrySet()) {\n            result.add(entry.getValue());\n        }\n       return result;\n    }\n}\n```\n\n","categories":["力扣","算法"]},{"title":"Docker一键部署SpringBoot项目","url":"/2022/05/19/在IDEA上配置连接Docker一键部署SpringBoot项目/","content":"\n## 在IDEA上配置连接Docker一键部署SpringBoot项目\n\n*按照以往的SpringBoot部署方法，就是将SpringBoot项目打包成jar包，然后在服务器上的Java环境下运行。这个方法还是挺繁琐的，因为存在着上传jar包的操作，同时还要要求服务器上的环境要和本地机器的环境版本一致，现在既然可以使用Docker，那也就可以实现一键部署项目的操作，省去了部署时带来的麻烦步骤。*\n\n#### 一、修改服务器中的Docker配置文件，开启远程访问\n\n修改daemon.json配置：\n\n```bash\nvim /etc/docker/daemon.json\n```\n\n加入以下内容：\n\n```baash\n\"hosts\": [\"tcp://0.0.0.0:2375\", \"unix:///var/run/docker.sock\"]//注意服务器的安全性，因为我这里时本地服务器，所有访问都是在内网进行的，所以可以不限制其IP地址\n```\n\n重启dockers服务：\n\n```bash\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n查看是否生效：\n\n```bash\ncurl docker服务器的IP地址:2375/info\n```\n\n如果有相关内容则证明已经可以正常的远程访问\n\n#### 二、修改IDEA设置，连接docker服务\n\n打开idea，进入Settings->Build,Execution,Deployment->Docker\n\n选择TCP socket ->Engine API URL 输入以下URL：\n\n```\ntcp://服务器IP地址:2375 \n```\n\n出现Connection successful即是表示已经成功连接了\n\n#### 三、Spring Boot整合一键部署插件\n\n添加pom依赖：\n\n```xml\n<!--docker-maven-plugin插件打包-->\n<plugin>\n    <groupId>com.spotify</groupId>\n    <artifactId>docker-maven-plugin</artifactId>\n    <version>1.0.0</version>\n    <configuration>\n        <!--镜像名称-->\n        <imageName>${docker.image.prefix}/${project.artifactId}</imageName>\n        <!--指定标签-->\n        <imageTags>\n            <imageTag>latest</imageTag>\n        </imageTags>\n        <!--基础镜像jdk1.8-->\n        <baseImage>java</baseImage>\n        <!--制作者提供本人信息-->\n        <maintainer>dt@email.com</maintainer>\n        <!--切换到Root目录-->\n        <workdir>/ROOT</workdir>\n        <cmd>[\"java\", \"-version\"]</cmd>\n        <entryPoint>[\"java\", \"-jar\", \"${project.build.finalName}.jar\"]</entryPoint>\n\n        <!--指定DockerFile路径-->\n        <!--<dockerDirectory>${project.basedir}/src/main/docker</dockerDirectory>-->\n\n        <!--指定远程docker api地址-->\n        <dockerHost>http://192.168.31.6:2375</dockerHost>\n\n        <!-- 这里是复制 jar 包到 docker 容器指定目录配置 -->\n        <resources>\n            <resource>\n                <targetPath>/ROOT</targetPath>\n                <!--用于指定需要复制的根目录-->\n                <directory>${project.build.directory}</directory>\n                <!--用于指定需要复制的jar文件-->\n                <include>${project.build.finalName}.jar</include>\n            </resource>\n        </resources>\n    </configuration>\n</plugin>\n\n```\n\n添加完成后，切换终端输入执行命令打包：\n\n```\nmvn clean package docker:build\n```\n\n等待打包完成后，就可以在idea的docker功能中查看已经生成的docker镜像了，同时项目插件已经也把运行的同一Java版本的镜像也一起下载了，接下来只要用docker start命令启动或者在idea中手动启动即可。","tags":["docker","springboot"],"categories":["笔记","学习","部署项目"]},{"title":"原生JS实现文件上传操作","url":"/2022/05/04/原生JS实现文件上传操作/","content":"\n### 前提概要\n\n*今天在做需求的时候碰到一个情况，需要在不能动网页的原有源码的情况下，实现Excel文件上传至后端接口做数据分析。*\n\n#### 解决办法分析\n\n在可以使用原生的JS的环境下，我们自然用了document.createElement方法来给现有的网页动态得新增文件上传按钮，然后利用document.addeventlistener事件监听文件变化，触发文件上传至后端的动作。其次就是构建xhr请求对象完成与后端交互过程\n\n具体JS代码如下：\n\n```javascript\n\n  var fileList = document.getElementById('createbtn').files;\n  if (!fileList.length) {\n    alert('请选择文件');\n    return;\n  }\n  var file = new FormData(); //构造FormData对象\n  // file.append('title', document.getElementById('title').value);\n\n  //多文件上传需要遍历添加到 fromdata 对象\n  // for (var i = 0; i < fileList.length; i++) {\n  //   file.append('file', fileList[i]); //支持多文件上传\n  // }\n  file.append(\"file\",fileList[0])\n\n  for (var value of file.values()) {\n    console.log(value);\n  }\n\n  var xhr = new XMLHttpRequest(); //创建对象\n\n  xhr.open(\"POST\", \"后端接口地址\");\n\t// 在调试期间发现如果自己定义Content-Type的话会出错，把它注解后就正常了\n  // xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\");\n  xhr.setRequestHeader(\"Access-Control-Allow-Origin\",\"*\")\n  xhr.send(file); //发送时  Content-Type默认就是: multipart/form-data; \n  xhr.onreadystatechange = function () {\n    console.log('state change', xhr.readyState);\n    if (this.readyState == 4 && xhr.status === 200) {\n\n      var obj = JSON.parse(xhr.responseText); //返回值\n      console.log(obj);\n      if(obj.code == 200){\n        alert('上传成功');\n      }\n    }\n  }\n```\n\n#### 过程遇到的一些问题\n\n1、因为调试需要用到Https协议，虽然这些东西都可以搞到，但这只仅仅是测试也太麻烦了。所以我找了好久，发现花生壳内网穿透还挺方便的。直接给部署在本地的项目套个Https协议，一劳永逸。\n\n2、开始给xhr加了个multipart/form-data的请求头，后面发现后台出现no multipart boundary错误。通过排查发现如果不用给它加上这个请求头的话就能正常解析了，因为浏览器会自动检测二进制文件，所以这个Content-type要为空！\n\n3、既然是前后端分离，那同源政策避免不了。之前在用Vue框架的的时候解决同源政策的方法是设置代理。但这次的前端我们是只能在JS层面上修改的，其他源文件什么的我们都是改不了的。既然如此，就给后端SpringBoot项目加个Webconfig配置类来解决吧！\n\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n    /**\n     * 增加对跨域对支持\n     * @param registry\n     */\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")// 这是请求映射路径\n                .allowedHeaders(\"*\")// 这里是所有请求头的意思\n                .allowedOrigins(\"*\")// 允许任何源反问（不安全），这里一般填前端域名\n                .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\")\n                .maxAge(3600)\n                .allowCredentials(true);\n    }\n}\n```\n\n","tags":["JavaScript","文件上传"],"categories":["笔记"]},{"title":"力扣-替换所有问号","url":"/2022/04/30/力扣—替换所有的问号（1576）/","content":"\n\n\n### 替换所有的问号（1576）\n\n##### 一、问题\n\n给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。\n\n注意：你 不能 修改非 '?' 字符。\n\n题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。\n\n在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。\n\n##### 二、例子\n\n```\n输入：s = \"??yw?ipkj?\"\n输出：\"acywaipkja\"\n```\n\n```\n输入：s = \"ubv?w\"\n输出：\"ubvaw\"\n解释：该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n```\n\n##### 三、思考\n\n​\t重点是在于将？替换成其他字符，并且字符不可以连续重复，也就是说可以多种答案出现，难度比较简单。\n\n​\t解决方法很简单，就是比较当前字符，如果是？则将用StringBuilder对象存入24个字母中的一个，只要它对比前后两个字符**不要连续重复**即可。那么我们设置前字符的下标变量为pre，而后字符的下标变量next。\n\n​\t因为前字符都来自StringBuilder对象（已过滤？的字符），所以无需有判断是否是？的步骤。如果后字符是？的情况，那只需要对比前字符即可，因为当前下标是会循环完所有的字符，这样做也就等于同时对比了前后这两个字符的情况。如果后字符不是？的情况，只需对比前后两个字符是否相同，并且代替的字符不跟这两个字符的相等即可。\n\n​\t最后再加上一些，例外情况，如？是在开头或者结尾等，基本实现代码如下。\n\n##### 四、代码实现\n\n```java\nclass Solution {\n    public String modifyString(String s) {\n        char[] words = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\n        StringBuilder sb = new StringBuilder();\n    \n        for(int i=0;i < s.length();i++){\n            char c = s.charAt(i);\n            //判断是否进行替换操作\n            if(c == '?'){\n                //判断？的位置是否为头部\n                if(sb.length() != 0){\n                    char pre = sb.charAt(sb.length()-1);\n                    char next =  i+1 != s.length() ? s.charAt(i+1)  : ' ';\n                    //如果next不是？的情况\n                    if(next != '?' && next != ' '){\n                        char t = ' ';\n                        for(int j =0;j < words.length;j++){\n                            //判断替换的字符与next和pre不一样\n                            if(pre != words[j]){\n                                if(next != words[j]){\n                                    t = words[j];\n                                    break;\n                                }\n                            }\n                        }\n                        if(t != ' '){\n                            sb.append(t);\n                        }\n                     //如果next是？或者是空的情况\n                    }else{\n                        for(int j =0;j < words.length;j++){\n                            if(pre != words[j]){\n                                sb.append(words[j]);\n                                break;\n                            }\n                        }\n                    }\n                 //如果？位置在头部\n                }else{\n                    if(i+1 != s.length()){\n                        char next = s.charAt(i+1);\n                         for(int j =0;j < words.length;j++){\n                            if(next != words[j]){\n                                sb.append(words[j]);\n                                break;\n                            }\n                        }\n                    }else{\n                        sb.append(words[0]);\n                    }\n                }\n                //如果不进行替换操作，不改变当前字符，加入到StringBuilder对象中\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n\n    }\n}\n```\n\n","tags":["力扣","连续不重复字符","算法"],"categories":["笔记"]},{"title":"经典排序算法总结","url":"/2021/12/22/经典排序算法总结/","content":"\n### 经典排序算法总结\n\n*最近在复习一下leetcode的算法题，发现自己对排序算法相关的知识记忆不深刻，数据结构里学的相关算法都忘得差不多了，并且自己之前做的笔记也找不到了，面对排序相关问题都没有思路下手。所以我打算借这次刷算法的题的机会，把之前所学习的内容复习一遍，并且做好电子版的笔记，将其记录下来，以后也可以比较轻松的复习相关知识！*\n\n##### 1、关于冒泡排序\n\n冒泡排序算是比较简单的排序算法了吧，它的原理非常简单，就是通过对比相邻的两个元素，逐渐的把这次比较结果里最大的数放到最后一位，在完成这次排序操作后，数组下标将重新返回数组的第一项元素并且重复以上操作一直到排序完成。\n\n###### （1）代码实现\n\n```java\npublic static int[] bubbleSort(int[] array){\n  if(array.length == 0)return array;\n  for(int i = 0;i<array.length;i++){\n    //一步步减少j循环的界限，因为冒泡排序的右边是已经完成排序的排列\n    for(int j=0;j<array.length-i-1;j++){\n      //两个元素之间交换位置\n      if(array[j]>array[j+1]){\n        int temp = array[j+1];\n        array[j+1] = array[j];\n        array[j] = temp;\n        \n      }\n    }\n  }\n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)  \n\n##### 2、关于选择排序\n\n选择排序是最稳定的排序算法之一，工作原理就是：在未排序的区域找到最小（或最大值）的元素，并将其交换放在第一位，接下来就分已排序区域和未排序区域，每次找到未排序区域的最小值（或最大值）将其加入到已排序区域的最后一位，多次重复操作直到数值有序化。\n\n###### （1）代码实现\n\n```java\npublic static int[] selectSort(int[] array){\n  \tif(array.length==0)return array;\n  \tfor(int i=0;i<array.length;i++){\n      int minIndex = i;\n      for(int j = i;j<array.length;j++){\n        if(array[j]<array[minIndex]){\n          minIndex = j;\n        }\n      }\n      int temp = array[minIndex];\n      array[minIndex] = array[i];\n      array[i] = temp;\n    }\n  \n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n2)   最差情况：T(n) = O(n2)  \n\n##### 3、关于插入排序\n\n###### （1）代码实现\n\n插入排序是默认从第二个数据开始比较，如果第二个数据比第一个数据小，则交换。然后在用第三个数据比较，如果比前面小则插入，否则退出循环。\n\n```java\npublic static int[] insertSort(int[] array){\n  \tif(array.length==0)return array;\n  \tfor(int i=1;i<array.length;i++){\n      for(int j = i;j > 0 ;j--){\n        if(array[j] < array[j-1]){\n          int temp = array[j-1];\n          array[j-1] = array[j];\n          array[j] = temp;\n        }else{\n          break;\n        }\n      }\n      \n    }\n  return array;\n}\n```\n\n###### （2）算法分析\n\n最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)  \n\n##### 4、关于快速排序\n\n快速排序是对冒泡排序的一种改进，它的基本思想就是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快排，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n###### （1）代码实现\n\n首先设定一个分界值，通过该分界值分成左右两个部分，将大于或等于分界值得数据集中到数组的右边，小于分界值得数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或分界值。然后就是在左右两边分别在取分界值，重复以上的步骤，最后得到的就是已经排序好的数组。\n\n```java\npublic static int[] quickSort(int[] array,int left,int right){\n\n        if(left < right){\n            int partitionIndex = partition(array,left,right);\n            quickSort(array,left,partitionIndex-1);\n            quickSort(array,partitionIndex + 1,right);\n        }\n        return array;\n    }\n    private static int partition(int[] array,int left,int right){\n        int pivot = left;\n        int index = pivot + 1;\n        for(int i = index; i <= right; i++){\n            if(array[i] < array[pivot]){\n                swap(array,i,index);\n                index++;\n            }\n        }\n        swap(array,pivot,index -1);\n        return index - 1;\n    }\n    private static void swap(int[] array,int i,int j){\n        int temp  = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n\n    }\n```\n\n\n\n###### （2）算法分析\n\n快速排序的性能在理想的情况下时间复杂度为：O(nlog2n)，最坏的情况下时间复杂度为：O(n2)","tags":["算法","排序"],"categories":["笔记"]},{"title":"记录M1芯片安装MySQL的步骤","url":"/2021/10/16/记录M1芯片安装MySQL的步骤/","content":"\n\n\n## MacOS M1芯片安装MySQL的步骤\n\n最近因为换了M1芯片的电脑，一些生产环境都要重新配置一下，毕竟CPU的架构换了，开发工具也需要更换成相对应的版本，MySQL就是其中的一个。因为在MySQL在docker下都是x64架构的，直接运行\n\n`docker pull mysql1`\n\n会报错“no matching manifest for linux/arm64/v8 in the manifest list entries”\n\n#### 1、下载镜像\n\n我们需要运行\n\n`docker pull mysql/mysql-server`\n\n在等待下载完成\n\n#### 2、启动容器\n\n启动docker容器，做好3306端口映射，设置密码为123456\n\n`docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql/mysql-server`\n\n#### 3、进入容器\n\n`docker exec -it mysql /bin/bash`\n\n正常情况输入mysql -uroot -p后登陆\n\n#### 4、修改可远程登陆设置\n\n`update user set host='%' where user='root';`\n\n最后flush privileges即可","tags":["MySQL","docker","M1"],"categories":["笔记"]},{"title":"记录n1盒子刷openwrt系统的步骤还有遇到的坑","url":"/2021/07/19/n1盒子刷openwrt系统的步骤还有遇到的坑/","content":"\n\n\n##                      n1盒子刷openwrt系统的步骤还有遇到的坑\n\n#### 1.斐讯n1的优点\n\n最近发现了openwrt系统的可玩性很高，除了有基本的WiFi无线功能外，系统还可以提供非常丰富的服务功能（很多都是我想要的）。通过精挑细选，我最终决定最高性价比的斐讯n1盒子。\n\n斐讯n1接口丰富：电源接口、千兆网口、HDMI、两个USB接口\n\n硬件配置：\n\n​\tCPU: S905D\n\n​\t内存：2G\n\n​    闪存：8G\n\n​\tWiFi：5G\n\n看到这样的配置才一百来块，心动不如行动，赶紧下单入坑。 \n\n#### 2.系统设置所踩到的坑\n\n本着省事的原则，在购买的时候就提前让卖家刷好openwrt系统，我拿到手后就可以直接使用了，结果事与愿违，在我进入页面的设置步骤的时候，嫌等待时间过长就把盒子的电源线拔了重插，结果后台管理页面就无法进入了。 \n\n进入电脑的网络设置观察，路由器的IP地址未知，但我通过显示器连接n1盒子看到系统是正常启动的，也就是很有可能是无线方面功能出了问题。没办法，只能自己重刷一次系统了。自己找了刷机教程慢慢探索\n\n#### 3.重新刷机步骤\n\n（1）准备一个U盘，下载diskgenius删除隐藏分区还有格式化U盘。\n\n（2）然后再下载balenaEtcher将op系统的img文件写入U盘。\n\n（3）等待写入完成后，就重启盒子（重启之前要插入U盘）。\n\n（4）现在盒子就会自动启动U盘里面的op系统，接下来就是输入一下两条命令\n\n`cd /root`\n\n`./install-to-emmc.sh`\n\n（5）后面就是按照脚本自动写入emmc，等待脚本写入完毕后就可以拔掉U盘，重新启动n1盒子了。\n\n#### 4.无线设置\n\n在浏览器中输入192.168.1.1，输入密码password进入管理后台。点击网络-接口-lan口-物理设置，把eth0选项去掉。新建一个接口，物理设置选择刚刚的eth0以太网适配器，然后在基本设置里选择PPPoE拨号，输入账号和密码后点击保存应用。现在就可以正常的上网了。\n\n","tags":["openwrt","n1盒子","linux","emmc"],"categories":["笔记"]},{"title":"使用注解@RequiresAuthentication出现的问题","url":"/2021/03/05/使用@RequiresAuthentication注解的时候，访问控制器报404/","content":"\n\n\n使用@RequiresAuthentication注解的时候，访问控制器报404\n\n这时候需要在shiro配置类加上\n\n```\n//Shiro注解支持\n@Bean\npublic AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {\n    AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\n    authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\n    return authorizationAttributeSourceAdvisor;\n}\n\n@Bean\npublic static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n\n    DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n    defaultAdvisorAutoProxyCreator.setUsePrefix(true);\n\n    return defaultAdvisorAutoProxyCreator;\n}\n```","tags":["注解","404错误"],"categories":["笔记"]},{"title":"shiro+jwt登录认证anon配置无效","url":"/2021/02/24/shiro+jwt登录认证anon配置无效/","content":"\n\n\n\n\n# shiro+jwt登录认证anon配置无效\n\n> \n\nshiroConfig的配置\n\n```java\n @Bean\n    public ShiroFilterFactoryBean factory(DefaultWebSecurityManager securityManager) {\n\n        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();\n\n        Map<String, Filter> filters = new HashMap<>();\n        filters.put(\"jwt\",new JwtFilter());\n        factoryBean.setFilters(filters);\n        factoryBean.setSecurityManager(securityManager);\n\n        Map<String, String> filterMap = new LinkedHashMap<>();\n\n        filterMap.put(\"/user/login\",\"anon\");\n        filterMap.put(\"/index/test\",\"anon\");\n        filterMap.put(\"/**\",\"jwt\");\n\n        factoryBean.setFilterChainDefinitionMap(filterMap);\n\n        return factoryBean;\n    }\n```\n\n\n\n结果发现\n\n` filters.put(\"jwt\", jwtFilter);`\n\n如果把jwtFilter注册里面的ioc容器bean的话\n\n访问所有的链接都会被拦截\n\n\n\n把jwtFilter的注入方式，改成new的话就anon配置就可以生效\n\n```\nfilters.put(\"jwt\", new JwtFilter()); \n1\n```\n\n但这样做的话，就无法使用自动注入的jwtUtil对象了\n\n这时候可以使用自己封装的spring上下文来获得bean\n\n```java\n if (jwtUtils == null) {\n        jwtUtils = ApplicationContextUtils.getBean(\"jwtUtils\");\n    }\n123\n```\n\n这样就可以成功注入了","tags":["shiro","jwt"],"categories":["笔记"]},{"title":"git工具的用法","url":"/2021/02/18/git用法/","content":"\n\n\n\n\n# git用法\n\n\n\n\n\ngit add 添加文件到缓存区\n\ngit commit -m \"描述\"从缓存区添加到版本库\n\ngit status 查看状态\n\n\n\ngit remote add orgin [url]  添加远程仓库\n\ngit  push origin master 添加版本库里面的内容到远程仓库\n\n\n\n\n\n#### 版本退回(返回上个commit版本)\n\ngit reset --hard head^\n\n^代表上个版本\n\n也可以head~100\n\n\n\ngit log 查找每次更新的版本号\n\ngit reset --hard [版本号]\n\n\n\n#### 撤销操作使用条件\n\ngit checkout -- file \n\n1.原本文件需要修改的文件没有添加到缓存区，现在撤销修改就回到版本库里面一样的\n\n2.原本的文件已经添加到缓存区里面，现在工作区修改错误，撤销修改就回到缓存区里面一样的\n\n\n\ngit reset HEAD file\n\n1.修改错误的文件已经添加到缓存区里面，就可以把暂存区的修改退回到工作区\n\n\n\n\n\n#### 分支\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`或者`git switch <name>`\n\n创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n\n\n#### bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n\n\n#### 多人协作\n\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n","tags":["git"],"categories":["学习"]},{"title":"正则表达式的规则","url":"/2021/01/02/首先是以下正则表达式的规则/","content":"\n\n\n\n\n\n\n今天要用到Java正则表达式来处理判断Ip地址是否正确的问题，所以复习一下正则表达式的相关知识\n\n# 首先是以下正则表达式的规则\n\n\\1. 任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。\n\n\\2. []代表匹配中括号中其中任一个字符，如[abc]匹配a或b或c。\n\n\\3. -在中括号里面和外面代表含义不同，如在外时，就匹配-，如果在中括号内[a-b]表示匹配26个小写字母中的任一个；[a-zA-Z]匹配大小写共52个字母中任一个；[0-9]匹配十个数字中任一个。\n\n\\4. ^在中括号里面和外面含义不同，如在外时，就表示开头，如^7[0-9]表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如[^abc]表示匹配出去abc之外的其他任一字符。\n\n\\5. .表示匹配任意的字符。\n\n\\6. \\d表示数字。\n\n\\7. \\D表示非数字。\n\n\\8. \\s表示由空字符组成，[ \\t\\n\\r\\x\\f]。\n\n\\9. \\S表示由非空字符组成，[^ \\ s 。\n\n\\10. \\w表示字母、数字、下划线，[a-zA-Z0-9_]。\n\n\\11. \\W表示不是由字母、数字、下划线组成。\n\n\\12. ?: 表示出现0次或1次。\n\n\\13. +表示出现1次或多次。\n\n\\14. *表示出现0次、1次或多次。\n\n\\15. {n}表示出现n次。\n\n\\16. {n,m}表示出现n~m次。\n\n\\17. {n,}表示出现n次或n次以上。\n\n\\18. XY表示X后面跟着Y，这里X和Y分别是正则表达式的一部分。\n\n\\19. X|Y表示X或Y\n\n\\20. (X)子表达式，将X看做是一个整体。\n\n上面的正则表达式的规则是非常简单明了的\n\nip地址的匹配的正则表达式是\n\n```java\n\"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n\n +\"(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\"\n```\n\n","tags":["正则表达式"],"categories":["学习"]},{"title":"Mac下安装Homebrew的步骤","url":"/2020/12/28/Macos系统安装Homebrew的步骤/","content":"\n\n\n\n\n### Mac下安装Homebrew的步骤\n\n##### 今天发现原来macos里面也有类似的linux系统里面的yum包管理系统--Homebrew，拥有它就可以轻松方便地为电脑安装安装你想要的软件或者命令，例如wget，只要输入brew install wget就可以一键完成下载操作了。但因为在国内访问国外源的速度很慢，还是换国内源比较好，现在记录一下安装Homebrew的安装和换源步骤\n\n### Hombrew安装的方法：\n\n官方给出的安装方法\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n但这个脚本一般在我们国内用不了，非常慢，所以我们需要换成以下的命令\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\"\n```\n\n如果卡在以下的信息：\n\n```shell\n==> Tapping homebrew/core\nCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...\n```\n\n请`ctrl+c断脚本执行如下命令：\n\n```shell\ncd \"$(brew --repo)/Library/Taps/\"\nmkdir homebrew && cd homebrew\ngit clone git://mirrors.ustc.edu.cn/homebrew-core.git\n```\n\n成功执行之后继续执行前文的安装命令。\n\n最后看到`==> Installation successful!`就说明安装成功了。\n\n`cask`同样也有首次下载缓慢的问题，解决方法大致同上：\n\n```shell\ncd \"$(brew --repo)/Library/Taps/\"\ncd homebrew\ngit clone https://mirrors.ustc.edu.cn/homebrew-cask.git\n```\n\n最后执行：\n\n```shell\nbrew update\n```\n\n### 换镜像：中科大源\n\n```shell\ngit -C \"$(brew --repo)\" remote set-url origin https://mirrors.ustc.edu.cn/brew.git\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git\n\nbrew update\n\n# 长期替换homebrew-bottles\necho 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' >> ~/.bash_profile\nsource ~/.bash_profile\n```\n\n注意`bottles`可以临时设置，在终端执行下面命令：\n\n```shell\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\n```\n\n### 卸载Homebrew\n\n一样使用以下的脚本就可以卸载：\n\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/uninstall)\"\n```\n\n### 恢复\n\n```shell\ngit -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git\n\nbrew update\n```\n\n`homebrew-bottles`配置只能手动删除，将 `~/.bash_profile`文件中的 `HOMEBREW_BOTTLE_DOMAIN=https://mirrors.xxx.com`内容删除，并执行 `source ~/.bash_profile`。\n\n### Homebrew基本用法\n\nbrew list  —列出已安装的软件\n\nbrew update  —更新Homebrew\n\nbrew home *—用浏览器打开\n\nbrew info  *—显示软件内容信息\n\nbrew deps * — 显示包依赖\n\nbrew server * —启动web服务器，可以通过浏览器访问http://localhost:4567/ 来同网页来管理包\n\nbrew –help —查看brew的帮助\n\nbrew install git —安装软件\n\nbrew uninstall  —卸载软件\n\nbrew search   —搜索软件\n\nbrew upgrade  —更新某具体软件\n\nbrew cleanup —删除程序，和upgrade一样，单个软件删除和所有程序老版删除。\n\nbrew outdated —查看那些已安装的程序需要更新","tags":["MacOS","Homebrew"],"categories":["笔记"]},{"title":"学习@Autowired和@Resource注解区别","url":"/2020/12/27/@Autowired和@Resource注解区别/","content":"\n\n\n\n\n\n\n### @Autowired和@Resource注解区别\n\n#### 当我们遇到以下情况的时候，@AutowireJ注解注入就会抛出异常\n\n```\npublic Interface UserService(){\n\tUser selectById(Integer id);\n}\n```\n\n```\n@service(\"userservice1\")\npublic class UserServiceImp1() implements UserService{\n\t@Override\n\tpublic User selectById(Integer id){}\n}\n```\n\n```\n@service(\"userservice2\")\npublic class UserServiceImp2() implements UserService{\n\t@Override\n\tpublic User selectById(Integer id){}\n}\n```\n\n####  这时候就需要运用到@Qualifier注解就可以解决这个问题\n\n```@\n@Autowired\n@Qualifier(name=\"userservice1\")\nprivate UserService userSerivce;\n```\n\n#### 或者使用@Resource\n\n```\n@Resource(name=\"userserivce1\")\nprivate UserService userSerivce;\n```\n\n#### 总结\n\n##### 1.@Autowired和@Resource都可以用来配装bean\n\n##### 2.@Autowired是根据类型进行自动配装，如果有多个类型一样的Bean的候选者的时候，就需要限定其中一个候选者，否者会抛出异常。但可以配合@Qualifier注解使用，例如：\n\n```\n@Autowired\n@Qualifier(\"baseDao\")\nprivate BaseDao basDao;\n```\n\n##### 3.@AUtowired如果想要允许Null,可以设置它的required属性为false\n\n##### 4.@Resource默认按name注入，可以通过name和type属性进行选择性注入","tags":["spring"],"categories":["笔记"]},{"title":"mybatis-plus时出现错误的解决的方法","url":"/2020/12/26/记录使用mybatis-plus时出现错误的解决办法/","content":"\n\n\n\n\n### 记录使用mybatis-plus时出现错误的解决办法\n\n今天想测试一下mybatis-plus框架的实用性，结果遇到了报错问题一直解决不了，现在先把如何解决的方法记录一下\n\n#### 1.引用mybatis-plus框架\n\n#### 2.创建实体类User\n\n#### 3.创建一个UserMapper\n\n```\n@Mapper\npublic interface UserMapper extends BaseMapper<User> {\n}\n```\n\n#### 4.application.yml内容\n\n```\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true\n    username: root\n    password: 12345678\n\nmybatis-plus:\n  configuration:\n    map-underscore-to-camel-case: true\n    auto-mapping-behavior: full\n  mapper-locations: classpath*:mapperxml/*Mapper.xml\n  global-config:\n    # 逻辑删除配置\n    db-config:\n      # 删除前\n      logic-not-delete-value: 1\n      # 删除后\n      logic-delete-value: 0\n```\n\n#### 5.在测试类直接测试\n\n```\n@Autowire\nprivate UserMapper userMapper\n\n@Test\n    void contextLoads() {\n        User user = new User();\n        user.setUid(1);\n        user.setBalance(150);\n        user.setPassword(\"123456\");\n        user.setUname(\"xiao\");\n        System.out.println(userMapper.insert(user));\n    }\n```\n\n#### 6.结果报错Property 'sqlSessionFactory' or 'sqlSessionTemplate' are required\n\n查找到以下的解决方法：\n\n##### （1）springboot启动类的@SpringBootApplication注解去掉exclude= {DataSourceAutoConfiguration.class}\n\n###### 没办法解决，因为并没有使用到exclude= {DataSourceAutoConfiguration.class}这个选项\n\n##### （2）dao层是继承于一个dao基类，所以只要在这个基类中注入任意一个属性\n\n```\n public class CommonDao extends SqlSessionDaoSupport {\n    @Resource\n     public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory){\n         super.setSqlSessionFactory(sqlSessionFactory);\n     }\n```\n\n无法解决，因为dao层mapper使用的都是接口，并且都是继承BaseMapper\n\n##### （3）加入以下依赖\n\n```\n<dependency>\n\t\t\t<groupId>com.alibaba</groupId>\n\t\t\t<artifactId>druid-spring-boot-starter</artifactId>\n\t\t\t<version>1.1.9</version>\n</dependency>\n```\n\n加入了也没有起作用\n\n最后在别人的mybatis-plus项目找到了相符合的版本，修改成以下的依赖才解决此问题\n\n```\n<dependency>\n<groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus</artifactId>\n    <version>2.1.8</version>\n</dependency>\n        <dependency>\n         <groupId>com.baomidou</groupId>\n         <artifactId>mybatisplus-spring-boot-starter</artifactId>\n          <version>1.0.5</version>\n</dependency>\n```\n\n最后想要说明的是，使用mybatis-plus时，要注意把mybatis,mybatis-spring的依赖删掉，以免造成不必要的冲突\n\n","tags":["mybatis-plus"],"categories":["笔记"]},{"title":"学习@Bean和@Commponent的区别","url":"/2020/12/26/@Bean 和 @Component的区别/","content":"\n\n\n# @Bean 和 @Component的区别\n\n## 前言　　\n\n最近研究Springboot 源码的时候发现这两个注解比较常出现，但是放眼看去这两个注解好像功能都差不多，所以专门研究了一下：\n\n------\n\n \n\n## 注解作用\n\n- @Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。\n- @Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。\n\n \n\n------\n\n \n\n## 两者对比\n\n相同点：两者的结果都是为spring容器注册Bean.\n\n不同点：@Component 通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。\n\n　　　　@Bean 注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。\n\n------\n\n## 理解\n\n@Component （@Controller @Service @Respository）作用于类上，只有在我们的SpringBoot应用程序启用了组件扫描并且包含了被注解的类时才有效。通过组件扫描，Spring将扫描整个类路径，并将所有@Component注释类添加到Spring Context，这里有的不足就是会把整个类当成bean注册到spring 容器上，如果这个类中并不是所有方法都需要注册为bean的话，会出现不需要的方法都注册成为bean，这时候必须确保这些不需要的方法也能注册为bean或者在扫描中加filter 过滤这些不需要的bean,否者spring将无法成功启动。\n\n@Bean相对来说就更加灵活了，它可以独立加在方法上，按需注册到spring容器，而且如果你要用到第三方类库里面某个方法的时候，你就只能用@Bean把这个方法注册到spring容器，因为用@Component你需要配置组件扫描到这个第三方类路径而且还要在别人源代码加上这个注解，很明显是不现实的。","tags":["spring","注解"],"categories":["笔记"]},{"title":"mysql定时自动备份","url":"/2020/12/23/记录自己今天实现两台服务器中的docker环境下mysql自动备份/","content":"\n\n\n\n\n### 记录自己今天实现两台服务器中的docker环境下mysql自动备份\n\n我这台谷歌云服务器相对于国内几家云服务器来讲不稳定，不知道会因为什么原因突然连不上，那服务器里面的mysql数据库没了就真的没了。加上国内屏蔽了谷歌的服务，如果以后想进入谷歌云控制台对服务器进行操作的话还需要翻墙，整体来讲太麻烦了，所以我计划把这台服务器的在docker容器里面的Mysql进行备份，然后根据脚本定时向我另外一台阿里云服务器进行传输备份文件，保证数据不丢失。今天查了一下，发现实现还是挺简单的，所以记录一下。\n\n### 1.配置两服务器的免密码sshd登录\n\n为实现阿里云免登录到谷歌云的服务器上\n\n首先在阿里云服务器上输入\n\n```linux\n#查看是否生成公钥和秘钥文件 \nls ~/.ssh\n\n#如果没有生成id_rsa 和id_rsa.pub文件就执行以下代码\nssh-keygen -t rsa\n\n#查看id_rsa.pub里面的内容,并复制\ncat id_rsa.pub\n```\n\n接下来在谷歌云服务器上输入\n\n```\nvi ~/.ssh/authorized_keys\n把上面复制内容粘贴在这文件上，输入wq保存\n```\n\n最后成功实现阿里云ssh免密码连接到谷歌云服务器\n\n\n\n### 2.在谷歌云服务器设置定时任务，每天备份mysql里面的数据\n\n编写备份的脚本 backupdb.sh\n\n```shell\n#!/bin/sh\ndb_user=\"数据库用户名\"\ndb_passwd=\"数据库密码\"\ndb_name=\"需要备份的数据库名\"\nCONTAINERNAME=\"docker容器的名\"\nname=\"$(date +\"%Y%m%d%H%M%S\")\"\ndocker exec -i $CONTAINERNAME /usr/bin/mysqldump -u$db_user -p$db_passwd $db_name >>/var/lib/docker/volumes/_data/backup/$name.sql\n# 保留最近一个月的数据\nfind /var/lib/docker/volumes/_data/backup -type f -mtime +20 -name \"*.sql\" -exec rm -rf {} \\;\n```\n\n启动定时任务\n\n```\n# 启动定时任务\ncrontab -e\n# 每天的3点30分执行脚本\n30 3 * * * /bin/bash /usr/data/backup/backupdb.sh\n\n# 查看定时任务列表\ncrontab -l\n```\n\n\n\n可以看到到计划时间后，已经成功保存备份文件\n\n![截屏2020-12-23 下午12.21.38](/Users/mac/Library/Application Support/typora-user-images/截屏2020-12-23 下午12.21.38.png)\n\n\n\n\n\n### 3.阿里云设置定时脚本，通过scp命令，每天定时的传备份文件过来\n\n编写\n\n定时任务脚本back.sh\n\n```shell\n#!/bin/sh\nname=\"$(date +\"%Y%m\")\"\nServerIp=\"你的服务器ip地址\"\nscp root@$ServerIp:/var/lib/docker/volumes/_data/backup/$name*.sql /usr/data/backupdb/ \n```\n\n启动定时任务\n\n```\n# 启动定时任务\ncrontab -e\n# 每天的12点01分执行脚本\n01 12 * * * /bin/bash /usr/data/backup/back.sh\n\n# 查看定时任务列表\ncrontab -l\n```\n\n阿里云可以看到成功显示备份文件\n\n![截屏2020-12-23 下午12.33.09](/Users/mac/Library/Application Support/typora-user-images/截屏2020-12-23 下午12.33.09.png)\n\n\n\n\n\n### 4.总结一下遇到的小问题\n\nscp传输的时候总要明确文件名，总不能每次传输把以前的备份文件都传一遍吧，但两台服务器的时间不一样，文件又想以时间命名方便一点管理，又不想改变两台服务器的时间。这时候就需要想个解决这个困难的方法，对比两台服务器的时间，我们就以当前时间为标准，因为此时是同日期但不同小时分钟的，而且我们设定的备份的频率是每天一次，所以备份文件的前面的年月是不同的，那我们以匹配相同时间前缀，这样就可以阿里云服务器就可以确保备份到最新的sql文件\n\n","tags":["linux","docker","mysql"],"categories":["笔记"]}]